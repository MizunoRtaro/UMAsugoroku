<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DOG LEARN</title>
    <style>
        body { margin: 0; display: flex; justify-content: center; align-items: center; height: 100vh; font-family: Arial, sans-serif; }
        canvas { display: block; position: absolute; top: 0; left: 0; z-index: 0; }
        #appTitle { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); color: white; font-size: 36px; font-weight: bold; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); z-index: 1; white-space: nowrap; }
        #timer { display: none; }
        #startButton { display: none; }

        .judgment-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
        }

        .judgment-content {
            background-color: #2c3e50;
            margin: 15% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 500px;
            color: #ecf0f1;
            font-family: 'Arial', sans-serif;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(255,255,255,0.1);
        }

        .judgment-content h2 {
            margin-top: 0;
            color: #e74c3c;
        }

        .judgment-input {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            border: none;
            background-color: #34495e;
            color: #ecf0f1;
            font-size: 16px;
            border-radius: 5px;
        }

        .judgment-button {
            background-color: #e74c3c;
            color: white;
            padding: 10px 20px;
            border: none;
            cursor: pointer;
            font-size: 16px;
            border-radius: 5px;
            transition: background-color 0.3s;
        }

        .judgment-button:hover {
            background-color: #c0392b;
        }

        #choices {
            margin-top: 10px;
        }
        #choices label {
            display: block;
            margin-bottom: 5px;
        }
        #questionText {
            font-weight: bold;
            margin-bottom: 10px;
        }

        .hell-button {
            position: absolute;
            width: 120px;
            padding: 10px;
            background-color: #8B0000;
            color: #FFD700;
            border: 2px solid #FF4500;
            border-radius: 5px;
            font-family: 'Arial', sans-serif;
            font-weight: bold;
            text-shadow: 1px 1px 2px #000;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 2;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .hell-button:hover {
            background-color: #FF4500;
            color: #FFF;
            box-shadow: 0 0 10px #FF6347;
        }

        #helpButton {
            top: 10px;
            right: 10px;
        }

        #toggleView {
            top: 60px;
            right: 10px;
        }

        #mobileControls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 2;
            display: none;
        }

        #joystick {
            width: 150px;
            height: 150px;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            position: relative;
            touch-action: none;
        }

        #joystickKnob {
            width: 50px;
            height: 50px;
            background-color: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        #exitFighterButton {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background-color: #ff4500;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 10px;
            font-size: 16px;
            cursor: pointer;
            display: none;
            z-index: 1000;
        }

        .fighter-control {
            position: absolute;
            width: 60px;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.5);
            border: none;
            border-radius: 50%;
            font-size: 14px;
            color: #000;
            display: none;
        }

        #ascendButton, #descendButton {
            display: none;
            position: absolute;
            width: 60px;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.5);
            border: none;
            border-radius: 50%;
            font-size: 14px;
            color: #000;
            z-index: 3;
            transition: background-color 0.3s;
        }

        #ascendButton:active, #descendButton:active {
            background-color: rgba(255, 0, 0, 0.5);
        }

        #ascendButton {
            top: -70px;
            right: 0;
        }

        #descendButton {
            top: -70px;
            right: 70px;
        }

        @media (max-width: 768px) {
            #appTitle {
                font-size: 24px;
                top: 10px;
            }

            .hell-button {
                width: 100px;
                padding: 8px;
                font-size: 14px;
            }

            #helpButton {
                top: 50px;
            }

            #toggleView {
                top: 90px;
            }

            .fighter-control {
                display: block;
            }
        }

        #copyright {
            position: fixed;
            bottom: 5px;
            right: 5px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.5);
            font-family: Arial, sans-serif;
            z-index: 1000;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        #videoPlayer {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1001;
            width: 90vw;
            max-width: 800px;
            background-color: black;
            border-radius: 10px;
            overflow: hidden;
        }

        #videoPlayer iframe {
            width: 100%;
            aspect-ratio: 16 / 9;
        }

        #closeVideoButton {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.7);
            color: black;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            font-size: 20px;
            line-height: 1;
            cursor: pointer;
            z-index: 1002;
        }

        @media (max-width: 768px) {
            #videoPlayer {
                width: 95vw;
            }

            #closeVideoButton {
                top: 5px;
                right: 5px;
                width: 25px;
                height: 25px;
                font-size: 16px;
            }
        }

        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }

        #loadingBar {
            width: 80%;
            height: 20px;
            background-color: #333;
            border-radius: 10px;
            overflow: hidden;
        }

        #loadingProgress {
            width: 0%;
            height: 100%;
            background-color: #ff4500;
            transition: width 0.3s ease;
        }

        #loadingText {
            color: #fff;
            margin-top: 10px;
            font-family: Arial, sans-serif;
        }
    </style>
</head>
<body>
    <div id="loadingScreen">
        <div id="loadingBar">
            <div id="loadingProgress"></div>
        </div>
        <div id="loadingText">ロード中... 0%</div>
    </div>

    <div id="appTitle">地獄で学ぶ</div>
    <button id="helpButton" class="hell-button">操作説明</button>
    <button id="toggleView" class="hell-button">視点切替</button>

    <!-- モバイル用の操作コントロールを修正 -->
    <div id="mobileControls">
        <div id="joystick">
            <div id="joystickKnob"></div>
        </div>
        <button id="ascendButton" class="fighter-control">上昇</button>
        <button id="descendButton" class="fighter-control">下降</button>
    </div>
    <button id="exitFighterButton">降りる</button>

    <!-- 操作説明モーダル -->
    <div id="helpModal" style="display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.4);">
        <div style="background-color: #add3f2; margin: 15% auto; padding: 20px; border: 1px solid #888; width: 80%; max-width: 500px;">
            <h2>基本操作</h2>
            <p>PC操作：</p>
            <ul>
                <li>W: 前進</li>
                <li>A: 左に移動</li>
                <li>S: 後退</li>
                <li>D: 右に移動</li>
            </ul>
            <p>スマートフォン操作：</p>
            <ul>
                <li>画面下部のジョイスティックをタッチして移動</li>
            </ul>
            <button onclick="closeHelpModal()">閉じる</button>
        </div>
    </div>

    <div id="judgmentModal" class="judgment-modal">
        <div class="judgment-content">
            <h2>最後の審判</h2>
            <p>さ言え。汝の人生を総括せよ。</p>
            <input type="text" id="judgmentInput" class="judgment-input" placeholder="ここに入力...">
            <button onclick="submitJudgment()" class="judgment-button">審判を受け</button>
        </div>
    </div>

    <div id="copyright">© R creative lab</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/EXRLoader.js"></script>
    <script>
        // Three.jsのセット
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // ライトの追加
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 5);
        scene.add(directionalLight);

        // 地獄のような背景の作成
        const fogColor = new THREE.Color(0x330000); // 暗い赤色の霧
        scene.background = fogColor;
        scene.fog = new THREE.FogExp2(fogColor, 0.01); // 0.02から0.01に変更

        // 地面のテクスチャ設定
        const groundTexture = new THREE.TextureLoader().load('concrete_rock_path_diff_1k.jpg');
        groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
        groundTexture.repeat.set(10, 10);

        const lavaTexture = new THREE.TextureLoader().load('lava.jpg');
        lavaTexture.wrapS = lavaTexture.wrapT = THREE.RepeatWrapping;
        lavaTexture.repeat.set(10, 10);

        const groundMaterial = new THREE.MeshStandardMaterial({
            map: groundTexture,
            emissiveMap: lavaTexture,
            emissive: 0xff4400,
            emissiveIntensity: 0.5,
            roughness: 0.7,
            metalness: 0.3
        });

        const groundGeometry = new THREE.PlaneGeometry(1000, 1000);
        const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
        groundMesh.rotation.x = -Math.PI / 2;
        groundMesh.position.y = -5;
        scene.add(groundMesh);

        // 炎のような揺らめく光を追加
        const fireLight = new THREE.PointLight(0xff5500, 1, 100);
        fireLight.position.set(0, 20, 0);
        scene.add(fireLight);

        // 炎のアニメーション
        function animateFire() {
            const time = Date.now() * 0.005;
            fireLight.intensity = 1 + Math.sin(time) * 0.3;
            fireLight.position.x = Math.sin(time * 0.5) * 10;
            fireLight.position.z = Math.cos(time * 0.5) * 10;
            requestAnimationFrame(animateFire);
        }
        animateFire();

        let isFirstPerson = false;
        const thirdPersonOffset = new THREE.Vector3(0, 4.5, 12);
        const firstPersonOffset = new THREE.Vector3(0, 10, 10); // キャラクターのスケールに合わせてオフセットを調整

        // GLTFローダーの設定
        const gltfLoader = new THREE.GLTFLoader();
        let mixer;
        let character;
        let currentAction;
        let rogerAction;
        let runAction;
        let eyeMesh;
        let isCharacterLoaded = false;
        let isMoving = false;

        // クロスフェードの持続時間（秒）
        const FADE_DURATION = 0.5;

        // アセットの読み込み状況を追跡する変数
        let totalAssets = 0;
        let loadedAssets = 0;

        // ロード画面を更新する関数
        function updateLoadingScreen(progress) {
            const loadingProgress = document.getElementById('loadingProgress');
            const loadingText = document.getElementById('loadingText');
            loadingProgress.style.width = `${progress}%`;
            loadingText.textContent = `ロード中... ${Math.round(progress)}%`;
        }

        // アセットの読み込みが完了したときに呼び出される関数
        function assetLoaded() {
            loadedAssets++;
            const progress = (loadedAssets / totalAssets) * 100;
            updateLoadingScreen(progress);

            if (loadedAssets === totalAssets) {
                setTimeout(() => {
                    document.getElementById('loadingScreen').style.display = 'none';
                    startAnimationWhenReady();
                }, 500);
            }
        }

        // エラーハンドリング関数
        function handleLoadError(error) {
            console.error('アセットの読み込み中にエラーが発生しました:', error);
            assetLoaded(); // エラーが発生しても読み込みカウントを進める
        }

        // アセットの読み込み関数を修正
        function loadAsset(loader, path, onLoad) {
            totalAssets++;
            loader.load(
                path,
                (asset) => {
                    onLoad(asset);
                    assetLoaded();
                },
                undefined,
                handleLoadError
            );
        }

        // キャラクターの読み込みを修正
        loadAsset(gltfLoader, 'eyerun.glb', (gltf) => {
            character = gltf.scene;
            character.position.set(0, 0, 0);
            character.scale.set(5, 5, 5);
            scene.add(character);

            console.log('キャラクターが読み込まれました');

            // キャラクターの層構造をコンソールに出力
            console.log('キャラクターの階層構造:');
            character.traverse((node) => {
                console.log(node.name, node.type);
            });

            // eyeメッシュを探す
            character.traverse((node) => {
                if (node.name.toLowerCase().includes('eye')) {
                    eyeMesh = node;
                    console.log('目のメッシュが見つかりました:', eyeMesh);
                }
            });

            if (!eyeMesh) {
                console.warn('目のメッシュがつかりません');
            }

            mixer = new THREE.AnimationMixer(character);
            runAction = mixer.clipAction(gltf.animations[0]);

            // rogerアニメーションの読み込み
            loadAsset(gltfLoader, 'roger.glb', (rogerGltf) => {
                rogerAction = mixer.clipAction(rogerGltf.animations[0]);
                rogerAction.play(); // 初期状態でrogerアニメーションを再生
                currentAction = rogerAction;
            });

            isCharacterLoaded = true;
            updateCameraPosition();
        });

        let lastLogTime = 0;
        const logInterval = 1000; // ログを出力する間隔（ミリ秒）

        function updateCameraPosition() {
            if (!isCharacterLoaded) {
                return; // キャラクターが読み込まれていない場合は何もしない
            }

            if (isFirstPerson) {
                if (eyeMesh) {
                    const eyeWorldPosition = new THREE.Vector3();
                    eyeMesh.getWorldPosition(eyeWorldPosition);
                    
                    // 目の位置を少し上に調整
                    eyeWorldPosition.y += 0.3 * character.scale.y;
                    
                    camera.position.copy(eyeWorldPosition);
                    
                    // カメラの向きをキャラクターの向きにわせる
                    const lookAtPosition = new THREE.Vector3();
                    character.getWorldDirection(lookAtPosition);
                    lookAtPosition.multiplyScalar(10).add(eyeWorldPosition);
                    camera.lookAt(lookAtPosition);
                    
                    camera.fov = 70; // 視野角を広げる
                    camera.near = 0.05; // ニアクリッピング面をさらに近くに
                    camera.far = 1000;
                    camera.updateProjectionMatrix();
                } else {
                    console.warn('目のメッシュが見つかりません。代替位置を使用します');
                    camera.position.copy(character.position).add(new THREE.Vector3(0, 1.6 * character.scale.y, 0));
                    camera.quaternion.copy(character.quaternion);
                }
            } else {
                camera.position.copy(character.position).add(thirdPersonOffset);
                camera.lookAt(character.position);
                camera.fov = 75; // 三人称視点の視野角
                camera.near = 0.1;
                camera.far = 1000;
                camera.updateProjectionMatrix();
            }

            // 一定間でのみログを出力
            const currentTime = Date.now();
            if (currentTime - lastLogTime > logInterval) {
                console.log(`カメラ位置: x: ${camera.position.x.toFixed(2)}, y: ${camera.position.y.toFixed(2)}, z: ${camera.position.z.toFixed(2)}`);
                lastLogTime = currentTime;
            }
        }

        // アニメーションを切り替える関数
        function switchAnimation(from, to) {
            if (currentAction === to) return;

            to.reset();
            to.setEffectiveTimeScale(1);
            to.setEffectiveWeight(1);
            to.clampWhenFinished = true;
            to.crossFadeFrom(from, FADE_DURATION, true);
            to.play();

            currentAction = to;
        }

        // デバイスタイプを検出する関数
        function isMobileDevice() {
            return (typeof window.orientation !== "undefined") || (navigator.userAgent.indexOf('IEMobile') !== -1);
        }

        // モバイルコントロールの表示/非表示を切り替える
        const mobileControls = document.getElementById('mobileControls');
        if (isMobileDevice()) {
            mobileControls.style.display = 'block';
        }

        // ジョイスティックの制御を修正
        let joystick;
        let joystickKnob;
        let joystickActive = false;
        let joystickVector = { x: 0, y: 0 };

        function initJoystick() {
            joystick = document.getElementById('joystick');
            joystickKnob = document.getElementById('joystickKnob');

            joystick.addEventListener('touchstart', handleJoystickStart, { passive: false });
            joystick.addEventListener('touchmove', handleJoystickMove, { passive: false });
            joystick.addEventListener('touchend', handleJoystickEnd);

            // マウス操作のサポート（デバッグ用）
            joystick.addEventListener('mousedown', handleJoystickStart);
            document.addEventListener('mousemove', handleJoystickMove);
            document.addEventListener('mouseup', handleJoystickEnd);

            console.log('Joystick initialized'); // デバッグ用ログ
        }

        function handleJoystickStart(event) {
            event.preventDefault(); // タッイベントのデフォルト動作を防止
            joystickActive = true;
            updateJoystickPosition(event);
            console.log('Joystick start'); // デバッグ用ログ
        }

        function handleJoystickMove(event) {
            if (joystickActive) {
                event.preventDefault(); // タッチイベントのデフォルト動作を防止
                updateJoystickPosition(event);
                console.log('Joystick move'); // デバッグ用ログ
            }
        }

        function handleJoystickEnd(event) {
            joystickActive = false;
            joystickKnob.style.transform = 'translate(-50%, -50%)';
            joystickVector = { x: 0, y: 0 };
            console.log('Joystick end'); // デバッグ用ログ
        }

        function updateJoystickPosition(event) {
            const joystickRect = joystick.getBoundingClientRect();
            const centerX = joystickRect.left + joystickRect.width / 2;
            const centerY = joystickRect.top + joystickRect.height / 2;

            let clientX, clientY;
            if (event.touches) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }

            const deltaX = clientX - centerX;
            const deltaY = clientY - centerY;
            const distance = Math.min(joystickRect.width / 2, Math.sqrt(deltaX * deltaX + deltaY * deltaY));
            const angle = Math.atan2(deltaY, deltaX);

            const knobX = distance * Math.cos(angle);
            const knobY = distance * Math.sin(angle);

            joystickKnob.style.transform = `translate(calc(-50% + ${knobX}px), calc(-50% + ${knobY}px))`;

            joystickVector = {
                x: knobX / (joystickRect.width / 2),
                y: knobY / (joystickRect.height / 2)
            };

            console.log('Joystick vector:', joystickVector); // デバッグ用ログ
        }

        // キャラクターの移動制御を更新
        function moveCharacter() {
            if (!character) return;

            let isMovingNow = false;
            const moveVector = new THREE.Vector3();

            if (isMobileDevice() && joystickActive) {
                moveVector.x = joystickVector.x;
                moveVector.z = joystickVector.y; // ここの符号を変更（-を削除）
                isMovingNow = (Math.abs(joystickVector.x) > 0.1 || Math.abs(joystickVector.y) > 0.1);
            } else {
                if (keys['ArrowUp'] || keys['w']) {
                    moveVector.z -= 1;
                    isMovingNow = true;
                }
                if (keys['ArrowDown'] || keys['s']) {
                    moveVector.z += 1;
                    isMovingNow = true;
                }
                if (keys['ArrowLeft'] || keys['a']) {
                    moveVector.x -= 1;
                    isMovingNow = true;
                }
                if (keys['ArrowRight'] || keys['d']) {
                    moveVector.x += 1;
                    isMovingNow = true;
                }
            }

            if (isMovingNow) {
                moveVector.normalize().multiplyScalar(moveSpeed);
                character.position.add(moveVector);

                // キャラクターの向きを移動方向に合わせる
                if (moveVector.length() > 0) {
                    const targetRotation = Math.atan2(moveVector.x, moveVector.z);
                    character.rotation.y = targetRotation;
                }

                if (!isMoving) {
                    isMoving = true;
                    switchAnimation(rogerAction, runAction);
                }
            } else if (isMoving) {
                isMoving = false;
                switchAnimation(runAction, rogerAction);
            }

            updateCameraPosition();
        }

        // 初���化時にジョイスティックを設定
        function init() {
            // ... 既存の初期化コード ...

            if (isMobileDevice()) {
                initJoystick();
                document.getElementById('mobileControls').style.display = 'block';
            }
        }

        // init関数を呼び出す
        init();

        // アニメーションループ内でmoveCharacter()を呼び出していることを確認
        function animate() {
            requestAnimationFrame(animate);
            
            // ... 既存のコード ...

            if (isCharacterLoaded) {
                if (!isInFighter) {
                    moveCharacter(); // ここでmoveCharacter()を呼び出していることを確認
                    // ... 他の既存のコード ...
                } else {
                    controlFighter();
                    // ... 他の既存のコード ...
                }
            }
            
            // ... 既存のコード ...
            
            renderer.render(scene, camera);
        }

        // キャラクターの移動制御
        const moveSpeed = 0.2;
        const rotateSpeed = 0.05;
        const keys = {};

        document.addEventListener('keydown', (event) => {
            keys[event.key.toLowerCase()] = true;
            if (event.key.toLowerCase() === 'h' && !isInFighter && rogerAction) {
                currentAction.stop();
                rogerAction.reset().play();
                setTimeout(() => {
                    rogerAction.stop();
                    currentAction.reset().play();
                }, rogerAction._clip.duration * 1000);
            }
        });

        document.addEventListener('keyup', (event) => {
            keys[event.key.toLowerCase()] = false;
        });

        // 視点切り替えボタンのイベントリスナー
        document.getElementById('toggleView').addEventListener('click', () => {
            isFirstPerson = !isFirstPerson;
            updateCameraPosition()
        });

        // 操作説明ボタンのイベントリスナー
        document.getElementById('helpButton').addEventListener('click', showHelpModal);

        // 操作説明モーダルを表示する関数
        function showHelpModal() {
            document.getElementById('helpModal').style.display = 'block';
        }

        // 操作説明モーダルを閉じる関数
        function closeHelpModal() {
            document.getElementById('helpModal').style.display = 'none';
        }

        // Fighter.glbの読み込みと配置
        let fighter;
        let missileMesh;
        let jetMesh;
        let jetParticles = [];

        loadAsset(gltfLoader, 'Fighter2.glb', (gltf) => {
            fighter = gltf.scene;
            fighter.position.set(50, -3, 150);
            fighter.scale.set(10, 10, 10);

            // ミサイルとジェットのメッシュを探す
            fighter.traverse((node) => {
                if (node.isMesh && node.name.toLowerCase() === 'missile') {
                    missileMesh = node;
                    missileMesh.material = missileMesh.material.clone();
                    missileMesh.material.color.setHex(0xff0000);
                }
                if (node.isMesh && node.name.toLowerCase().includes('jet')) {
                    jetMesh = node;
                    console.log('ジェットのメッシュが見つかりました:', jetMesh);
                }
            });

            if (!missileMesh) {
                console.warn('ミサイのメッシュが見つかません');
            }
            if (!jetMesh) {
                console.warn('ジェットのメッシュが見つかりません');
            }

            scene.add(fighter);

            // 戦闘機の階層構コンソールに出力
            console.log('戦闘機の階層構造:');
            fighter.traverse((node) => {
                console.log(node.name, node.type);
            });
        });

        // キャラクターが戦闘機に近づいたかチェックする関数
        function checkProximityToFighter() {
            if (!character || !fighter) return;

            const distance = character.position.distanceTo(fighter.position);
            if (distance < 5) { // 5は近接判定の距離
                enterFighter();
            }
        }

        // 戦闘機に乗る関数
        let isInFighter = false;
        function enterFighter() {
            isInFighter = true;
            character.visible = false;
            camera.position.copy(fighter.position).add(new THREE.Vector3(0, 10, 50)); // カメラ位置を調整
            camera.lookAt(fighter.position);

            // スマートフォンの場合、降りるボタンと上昇・下降ボタンを表示
            if (isMobileDevice()) {
                document.getElementById('exitFighterButton').style.display = 'block';
                document.getElementById('ascendButton').style.display = 'block';
                document.getElementById('descendButton').style.display = 'block';
            }
        }

        // 戦闘機から降りる関数を定義
        function exitFighter() {
            if (!isInFighter) return;

            isInFighter = false;
            character.visible = true;
            
            // キャラクターの位置を戦闘機の位置に合わせて調整
            character.position.set(
                fighter.position.x,
                0, // 地面レベルに設定
                fighter.position.z
            );
            
            updateCameraPosition();

            // 降りるボタンと上昇・下降ボタンを非表示にする
            document.getElementById('exitFighterButton').style.display = 'none';
            document.getElementById('ascendButton').style.display = 'none';
            document.getElementById('descendButton').style.display = 'none';
        }

        // 降りるボタンのイベントリスナーを追加
        document.getElementById('exitFighterButton').addEventListener('click', exitFighter);

        // マウス操作のための変数を更新
        let mouseX = 0;
        let mouseY = 0;
        let targetRotationX = 0;
        let targetRotationY = 0;

        // マウスイベントーを更新
        document.addEventListener('mousemove', onMouseMove);

        function onMouseMove(event) {
            if (isInFighter) {
                mouseX = (event.clientX / window.innerWidth) * 2 - 1;
                mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
            }
        }

        // 戦闘機の操縦関数を更新
        function controlFighter() {
            if (!isInFighter) return;

            const fighterSpeed = 0.5;
            const rotateSpeed = 0.03;
            const mouseRotateSpeed = 0.03; // マウスの感度を上げる（0.01から0.03に変更）

            if (isMobileDevice()) {
                // スマートフォンでのジョイスティック操作
                if (joystickActive) {
                    fighter.translateZ(joystickVector.y * fighterSpeed); // ここの符号を変更
                    fighter.rotateY(-joystickVector.x * rotateSpeed);
                }
                // 上昇・下降ボタンの処理
                if (isAscending) {
                    fighter.translateY(fighterSpeed * 0.7);
                }
                if (isDescending) {
                    fighter.translateY(-fighterSpeed * 0.7);
                }
            } else {
                // PCでの通常の操作
                // マウス操作による回転
                targetRotationY += mouseX * mouseRotateSpeed;
                targetRotationX += mouseY * mouseRotateSpeed;

                // 回転の制限
                targetRotationX = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, targetRotationX));

                // 滑らかな回転の適用
                fighter.rotation.y += (targetRotationY - fighter.rotation.y) * 0.1;
                fighter.rotation.x += (targetRotationX - fighter.rotation.x) * 0.1;

                // キーボード操作
                if (keys['w']) {
                    fighter.translateZ(-fighterSpeed);
                }
                if (keys['s']) {
                    fighter.translateZ(fighterSpeed * 0.5);
                }
                if (keys['a']) {
                    fighter.translateX(-fighterSpeed * 0.5);
                }
                if (keys['d']) {
                    fighter.translateX(fighterSpeed * 0.5);
                }
                if (keys[' ']) {
                    fighter.translateY(fighterSpeed * 0.7);
                }
                if (keys['shift']) {
                    fighter.translateY(-fighterSpeed * 0.7);
                }
                if (keys['b']) {
                    fighter.translateZ(-fighterSpeed * 2);
                }
            }

            // メラの位置を更新
            updateFighterCamera();
        }

        // 戦闘機用のカメラ更新関数を更新
        function updateFighterCamera() {
            const cameraOffset = new THREE.Vector3(0, 5, 30); // カメラの位置を調整
            cameraOffset.applyQuaternion(fighter.quaternion);
            camera.position.copy(fighter.position).add(cameraOffset);
            camera.lookAt(fighter.position);
        }

        // ミサイル配列
        let missiles = [];

        // ルのジオメトリとマテリアルを作成
        const missileGeometry = new THREE.SphereGeometry(0.5, 32, 32);
        const missileMaterial = new THREE.MeshPhongMaterial({ color: 0xffff00 });

        // ミサイル発射関数
        function fireMissile() {
            if (!isInFighter || !fighter || !missileMesh) return;

            const missile = new THREE.Mesh(missileGeometry, missileMaterial);
            
            // サイルメッシュのワード位置を取得
            const missileWorldPosition = new THREE.Vector3();
            missileMesh.getWorldPosition(missileWorldPosition);
            
            // ミサイルの位置をミサイルメッシの位置に設定
            missile.position.copy(missileWorldPosition);
            
            // 戦闘機の前方を取得
            const fighterDirection = new THREE.Vector3(0, 0, -1).applyQuaternion(fighter.quaternion);
            
            // ミサイルの向きを戦闘機の前方向に合わせる
            missile.quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, -1), fighterDirection);

            scene.add(missile);
            missiles.push({ mesh: missile, speed: 2, lifespan: 100 });
        }

        // ミサイルの更新関数
        function updateMissiles() {
            missiles = missiles.filter(missile => {
                missile.mesh.translateZ(-missile.speed); // 前方に移動（-Z方向）
                missile.lifespan--;
                if (missile.lifespan <= 0) {
                    scene.remove(missile.mesh);
                    return false;
                }
                return true;
            });
        }

        // ジェット噴射パーティクルの作成
        function createJetParticle() {
            const particle = new THREE.Mesh(
                new THREE.SphereGeometry(0.05, 8, 8),
                new THREE.MeshBasicMaterial({
                    color: new THREE.Color(0.5 + Math.random() * 0.5, 0.8 + Math.random() * 0.2, 1),
                    transparent: true,
                    opacity: 0.7
                })
            );
            return particle;
        }

        // ジェット噴射効の更新
        function updateJetEffect() {
            if (!isInFighter || !jetMesh) return;

            // 新しいパーティクルを追加
            if ((keys['w'] || keys['b']) && jetParticles.length < 200) {
                const particleCount = keys['b'] ? 10 : 5; // ブースト時はパーティクル数を増やす
                for (let i = 0; i < particleCount; i++) {
                    const particle = createJetParticle();
                    const jetWorldPosition = new THREE.Vector3();
                    jetMesh.getWorldPosition(jetWorldPosition);
                    
                    // ジェットの位置を調整（より手前の-Y側に）
                    jetWorldPosition.add(new THREE.Vector3(
                        (Math.random() - 0.5) * 0.5,
                        -0.5 + (Math.random() - 0.5) * 0.3,
                        2 + Math.random() * 0.5
                    ).applyQuaternion(fighter.quaternion));
                    
                    particle.position.copy(jetWorldPosition);
                    scene.add(particle);
                    jetParticles.push({
                        mesh: particle,
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 0.2,
                            (Math.random() - 0.5) * 0.2,
                            (0.8 + Math.random() * 0.7) * (keys['b'] ? 2 : 1) // ブースト時は速度を2倍に
                        ).applyQuaternion(fighter.quaternion),
                        life: 20 + Math.random() * 20
                    });
                }
            }

            // パーティクルの更新
            jetParticles.forEach((particle, index) => {
                particle.mesh.position.add(particle.velocity);
                particle.mesh.material.opacity -= 0.02;
                particle.mesh.scale.multiplyScalar(1.02);
                particle.life--;

                if (particle.life <= 0) {
                    scene.remove(particle.mesh);
                    jetParticles.splice(index, 1);
                }
            });
        }

        // 敵の配列
        let enemies = [];
        // スコア
        let score = 0;

        // スコア表示用のHTML要素を加
        const scoreElement = document.createElement('div');
        scoreElement.style.position = 'absolute';
        scoreElement.style.top = '10px';
        scoreElement.style.left = '10px';
        scoreElement.style.color = 'white';
        scoreElement.style.fontSize = '24px';
        scoreElement.style.fontWeight = 'bold';
        scoreElement.style.zIndex = '100';
        document.body.appendChild(scoreElement);

        // 敵を生成る関数
        function spawnEnemy(modelPath, position, scale) {
            gltfLoader.load(modelPath, (gltf) => {
                const enemy = gltf.scene;
                enemy.position.copy(position);
                enemy.scale.set(scale, scale, scale);
                scene.add(enemy);
                enemies.push({ mesh: enemy, health: 100 });
            });
        }

        // 敵を配置
        spawnEnemy('SAMURAI.glb', new THREE.Vector3(20, 7, -20), 15);
        spawnEnemy('SAMURAI.glb', new THREE.Vector3(-20, 7, 20), 15);

        // 銃弾の配列
        let bullets = [];

        // 銃弾のオメトリとマテリアルを作成
        const bulletGeometry = new THREE.SphereGeometry(0.2, 8, 8);
        const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });

        // 銃弾発射関数
        function fireBullet() {
            if (!isInFighter || !fighter) return;

            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
            bullet.position.copy(fighter.position);
            
            // 戦闘機の前方向を取得
            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(fighter.quaternion);
            
            scene.add(bullet);
            bullets.push({ mesh: bullet, velocity: direction.multiplyScalar(2), lifespan: 100 });
        }

        // 銃弾の更新関数
        function updateBullets() {
            bullets = bullets.filter(bullet => {
                bullet.mesh.position.add(bullet.velocity);
                bullet.lifespan--;

                // 敵との衝突判定
                enemies.forEach((enemy, index) => {
                    if (bullet.mesh.position.distanceTo(enemy.mesh.position) < 6) {
                        enemy.health -= 20;
                        if (enemy.health <= 0) {
                            scene.remove(enemy.mesh);
                            enemies.splice(index, 1);
                            score += 100;
                        }
                        scene.remove(bullet.mesh);
                        return false;
                    }
                });

                if (bullet.lifespan <= 0) {
                    scene.remove(bullet.mesh);
                    return false;
                }
                return true;
            });
        }

        // マ���スクリックイベントリスナーを追加
        document.addEventListener('click', () => {
            if (isInFighter) {
                fireBullet();
            }
        });

        // 敵の動き制御する関数
        function moveEnemies(delta) {
            enemies.forEach(enemy => {
                // ランダムな方向と速度を設定
                if (!enemy.velocity) {
                    enemy.velocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 0.1,
                        (Math.random() - 0.5) * 0.1,
                        (Math.random() - 0.5) * 0.1
                    );
                    enemy.rotationSpeed = (Math.random() - 0.5) * 0.02;
                }

                // 位を更新
                enemy.mesh.position.add(enemy.velocity.clone().multiplyScalar(delta * 60));

                // 回転を更新
                enemy.mesh.rotation.y += enemy.rotationSpeed * delta * 60;

                // 境界チェックと方向転換
                if (Math.abs(enemy.mesh.position.x) > 50 || 
                    Math.abs(enemy.mesh.position.y) > 50 || 
                    Math.abs(enemy.mesh.position.z) > 50) {
                    enemy.velocity.negate();
                }
            });
        }

        // 溶岩モデルの配置
        function placeLava() {
            const lavaPositions = [
                { x: 30, y: 0, z: 20 },
                { x: -30, y: 0, z: 30 },
                { x: 3, y: -4, z: -25 },
                { x: -45, y: -4, z: -70 },
                { x: 35, y: -4, z: -5 }
            ];

            lavaPositions.forEach(position => {
                gltfLoader.load('lava.glb', (gltf) => {
                    const lava = gltf.scene;
                    lava.position.set(position.x, position.y, position.z);
                    lava.scale.set(30, 30, 30); // スケールを大きくしました
                    scene.add(lava);

                    // 発光効果を削除しました
                });
            });
        }

        // 寺院モルの配置
        function placeTemples() {
            const templePositions = [
                { x: 50, y: 20, z: -70, rotationY: Math.PI / 4, model: 'temple.glb', scale: 100 },
                { x: -80, y: 20, z: 50, rotationY: -Math.PI / 1, model: 'temple.glb', scale: 100 },
                { x: -10, y: 10, z: -150, rotationY: Math.PI / 1, model: 'temple2.glb', scale: 50 } // temple2.glbのスケールを変更
            ];

            templePositions.forEach(position => {
                gltfLoader.load(position.model, (gltf) => {
                    const temple = gltf.scene;
                    temple.position.set(position.x, position.y, position.z);
                    temple.rotation.y = position.rotationY;
                    temple.scale.set(position.scale, position.scale, position.scale); // 個別のスケールを適用
                    scene.add(temple);

                    // 地獄の雰囲気を出すための色調整（オプション）
                    temple.traverse((child) => {
                        if (child.isMesh) {
                            child.material.color.setHex(0x880000); // 暗い赤色
                            child.material.roughness = 0.8;
                            child.material.metalness = 0.2;
                        }
                    });
                });
            });
        }

        // グローバル変数として追加
        let enma;
        let isNearEnma = false;
        let enmaCooldown = false;

        // 閻魔大王の配置関数を修正
        function placeEnma() {
            gltfLoader.load('enma.glb', (gltf) => {
                enma = gltf.scene;
                enma.name = 'enma';
                enma.position.set(-20, 10, -70); // 位置を調整
                enma.scale.set(20, 20, 20); // スケールを調整
                enma.rotation.y = 0; // 回転をリセット（正面を向かせる）
                scene.add(enma);

                console.log('閻魔大王が配置されました:', enma.position);

                // devil1.glbを閻魔大王の近くに配置
                placeDevil();
            });
        }

        let devil;
        let devilMixer;

        // devil1.glbを配置する関数
        function placeDevil() {
            gltfLoader.load('devil1.glb', (gltf) => {
                devil = gltf.scene;
                devil.name = 'devil';
                devil.position.set(-50, -5, -50); // 閻魔大王の近くに配置
                devil.scale.set(10, 10, 10); // スケールを調整
                devil.rotation.y = Math.PI / 4; // 少し回転させる
                scene.add(devil);

                console.log('悪魔が配置されました:', devil.position);

                // アニメーションミキサーを作成
                devilMixer = new THREE.AnimationMixer(devil);

                // アイドリングアニメーション再生
                if (gltf.animations.length > 0) {
                    const idleAnimation = devilMixer.clipAction(gltf.animations[0]);
                    idleAnimation.play();
                }
            });
        }

        // 閻魔大王との接触を検出する関数を修正
        function checkEnmaProximity() {
            if (!character || !enma || enmaCooldown) return;

            const distance = character.position.distanceTo(enma.position);

            if (distance < 30 && !isNearEnma) {
                isNearEnma = true;
                showEnmaMessage();
                startEnmaCooldown();
            } else if (distance >= 30) {
                isNearEnma = false;
            }
        }

        // クールダウンを開始する関数
        function startEnmaCooldown() {
            enmaCooldown = true;
            console.log('閻魔大王との接触クールダウン開始');
            
            setTimeout(() => {
                enmaCooldown = false;
                console.log('閻魔大王との接触クールダウン了');
            }, 15000); // 15秒後にクールダウンを解除
        }

        // 問題のデータベース
        const questions = [
            {
                question: "仏教における四諦とは何か？",
                choices: ["苦・集・滅・道", "善悪・因・果", "生・老・病・死"],
                correctAnswer: 0
            },
            {
                question: "六道輪廻において、最も苦しいとされる世界は？",
                choices: ["人間道", "餓鬼道", "地獄道"],
                correctAnswer: 2
            },
            {
                question: "仏教の開祖は誰か？",
                choices: ["孔子", "釈迦牟尼仏", "子"],
                correctAnswer: 1
            },
            {
                question: "極楽浄土はどの方角���あるとされているか？",
                choices: ["東", "西", "南"],
                correctAnswer: 1
            },
            {
                question: "仏教における「三法印」とは何か",
                choices: ["諸行無常・諸法無我・涅槃寂静", "布施・持戒・忍辱", "身・口・意"],
                correctAnswer: 0
            }
        ];

        let currentQuestionIndex = 0;
        let correctAnswers = 0;

        // 審判モーダルの内容を変更
        function updateJudgmentModalContent() {
            const judgmentModal = document.getElementById('judgmentModal');
            judgmentModal.innerHTML = `
                <div class="judgment-content">
                    <h2>閻魔大王の審判</h2>
                    <p id="questionText"></p>
                    <div id="choices"></div>
                    <button onclick="submitAnswer()" class="judgment-button">回答する</button>
                </div>
            `;
        }

        // 問題を表示する関数
        function showQuestion() {
            const question = questions[currentQuestionIndex];
            document.getElementById('questionText').textContent = question.question;
            const choicesDiv = document.getElementById('choices');
            choicesDiv.innerHTML = '';
            question.choices.forEach((choice, index) => {
                choicesDiv.innerHTML += `
                    <input type="radio" name="answer" value="${index}" id="choice${index}">
                    <label for="choice${index}">${choice}</label><br>
                `;
            });
        }

        // 回答を提出する関数
        function submitAnswer() {
            const selectedAnswer = document.querySelector('input[name="answer"]:checked');
            if (selectedAnswer) {
                const answerIndex = parseInt(selectedAnswer.value);
                if (answerIndex === questions[currentQuestionIndex].correctAnswer) {
                    correctAnswers++;
                }
                currentQuestionIndex++;
                if (currentQuestionIndex < questions.length) {
                    showQuestion();
                } else {
                    showResult();
                }
            } else {
                alert('回答を選択してください。');
            }
        }

        // 結果を表示する関数
        function showResult() {
            const judgmentModal = document.getElementById('judgmentModal');
            if (correctAnswers >= 3) {
                judgmentModal.innerHTML = `
                    <div class="judgment-content">
                        <h2>審判結果</h2>
                        <p>正解数: ${correctAnswers}/5</p>
                        <p>極楽へ行くことが許されました。</p>
                        <a href="gokuraku.html" class="judgment-button">極楽へ行く</a>
                    </div>
                `;
            } else {
                judgmentModal.innerHTML = `
                    <div class="judgment-content">
                        <h2>審判結果</h2>
                        <p>正解数: ${correctAnswers}/5</p>
                        <p>まだ修行が足りません。この世界でさらに精進しましょう。</p>
                        <button onclick="closeJudgmentModal()" class="judgment-button">閉じる</button>
                    </div>
                `;
            }
        }

        // 審判モーダルを閉じる関数
        function closeJudgmentModal() {
            document.getElementById('judgmentModal').style.display = 'none';
            currentQuestionIndex = 0;
            correctAnswers = 0;
            updateJudgmentModalContent();
        }

        // 閻魔大王のメッセージを表示する関数
        function showEnmaMessage() {
            const messageDiv = document.createElement('div');
            messageDiv.id = 'enmaMessage';
            messageDiv.style.position = 'absolute';
            messageDiv.style.top = '50%';
            messageDiv.style.left = '50%';
            messageDiv.style.transform = 'translate(-50%, -50%)';
            messageDiv.style.background = 'rgba(0, 0, 0, 0.8)';
            messageDiv.style.color = 'white';
            messageDiv.style.padding = '20px';
            messageDiv.style.borderRadius = '10px';
            messageDiv.style.zIndex = '1000';
            messageDiv.innerHTML = `
                <p>まだ審判の時ではない。<br>「盆」について<br>ここで学ぶがよい。</p>
                <button onclick="closeEnmaMessage()">はい</button>
                <button onclick="reloadPage()">いいえ</button>
            `;
            document.body.appendChild(messageDiv);
        }

        // 閻魔大王のメッセージを閉じる関数
        function closeEnmaMessage() {
            const messageDiv = document.getElementById('enmaMessage');
            if (messageDiv) {
                messageDiv.remove();
            }
        }

        // 画面を黒くしてリロードする関数
        function reloadPage() {
            const blackScreen = document.createElement('div');
            blackScreen.style.position = 'fixed';
            blackScreen.style.top = '0';
            blackScreen.style.left = '0';
            blackScreen.style.width = '100%';
            blackScreen.style.height = '100%';
            blackScreen.style.backgroundColor = 'black';
            blackScreen.style.zIndex = '9999';
            blackScreen.style.display = 'flex';
            blackScreen.style.justifyContent = 'center';
            blackScreen.style.alignItems = 'center';
            blackScreen.style.fontSize = '48px';
            blackScreen.style.color = 'white';
            blackScreen.style.fontFamily = 'Arial, sans-serif';
            blackScreen.textContent = 'やりなおし。by閻魔';
            document.body.appendChild(blackScreen);

            setTimeout(() => {
                location.reload();
            }, 3000);
        }

        // 最後の審判の入力プロンプトを表示する関数を修正
        function showJudgmentPrompt() {
            updateJudgmentModalContent();
            document.getElementById('judgmentModal').style.display = 'block';
            showQuestion();
        }

        // キャラクターの位置をグ出力する関数を追加
        function logCharacterPosition() {
            if (character) {
                console.log('キャラクターの位置:', character.position);
        　　　}
        }

        // 定期的にキャラターの位置を��グに出力
        setInterval(logCharacterPosition, 5000); // 5秒ごとに位置をログ出力

        // キャラクターの読み込みを待ってかアニメーションを開始
        function startAnimationWhenReady() {
            if (isCharacterLoaded) {
                animate();
            } else {
                requestAnimationFrame(startAnimationWhenReady);
            }
        }

        // キーイベントリスナーに戦闘機から降りる機能を追加
        document.addEventListener('keydown', (event) => {
            keys[event.key.toLowerCase()] = true;
            if (event.key === 'e' && isInFighter) {
                exitFighter();
            }
            if (event.key === 'f' && isInFighter) {
                fireMissile();
            }
        });

        // 上昇・下降ボタンの状態を追跡する変数を追加
        let isAscending = false;
        let isDescending = false;

        // 上昇・下降ボタンのイベントリスナーを追加
        document.getElementById('ascendButton').addEventListener('touchstart', () => { isAscending = true; });
        document.getElementById('ascendButton').addEventListener('touchend', () => { isAscending = false; });
        document.getElementById('descendButton').addEventListener('touchstart', () => { isDescending = true; });
        document.getElementById('descendButton').addEventListener('touchend', () => { isDescending = false; });

        // マウス操作のサポート（デバッグ用）
        document.getElementById('ascendButton').addEventListener('mousedown', () => { isAscending = true; });
        document.getElementById('ascendButton').addEventListener('mouseup', () => { isAscending = false; });
        document.getElementById('descendButton').addEventListener('mousedown', () => { isDescending = true; });
        document.getElementById('descendButton').addEventListener('mouseup', () => { isDescending = false; });

        // アニメーションループ
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            
            if (mixer && isCharacterLoaded) {
                mixer.update(delta);
            }

            if (isCharacterLoaded) {
                if (!isInFighter) {
                    moveCharacter();
                    updateCameraPosition();
                    checkProximityToFighter();
                    checkEnmaProximity(); // 閻魔大王との距離をチェック
                    checkTVProximity(); // テレビとの距離をチェック
                    checkDevilProximity(); // 悪魔との距離をチェック
                } else {
                    controlFighter();
                    updateJetEffect(); // ジェット効果の更新を追加
                }
            }
            
            updateMissiles();
            updateBullets();
            updateScore();
            moveEnemies(delta);
            animateFire();
            
            // 溶岩のテクスチャアニメーション
            lavaTexture.offset.y += 0.001;
            
            // 溶岩のアニメーション（オプション）
            scene.children.forEach(child => {
                if (child.name === 'lava') {
                    child.rotation.y += 0.005;
                }
            });
            
            // devilのアニメーションを更新
            if (devilMixer) {
                devilMixer.update(delta);
            }
            
            renderer.render(scene, camera);
        }

        // スコア更新関数
        function updateScore() {
            scoreElement.textContent = `煩悩: ${score}`;
        }

        // レスポンシブ対応
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);

            // モバイルコントロールの表示/非表示を切り替え
            if (isMobileDevice()) {
                document.getElementById('mobileControls').style.display = 'block';
                // 戦闘機に乗っている場合のみ、上昇・下降ボタンと降りるボタンを表示
                if (isInFighter) {
                    document.getElementById('ascendButton').style.display = 'block';
                    document.getElementById('descendButton').style.display = 'block';
                    document.getElementById('exitFighterButton').style.display = 'block';
                } else {
                    document.getElementById('ascendButton').style.display = 'none';
                    document.getElementById('descendButton').style.display = 'none';
                    document.getElementById('exitFighterButton').style.display = 'none';
                }
            } else {
                document.getElementById('mobileControls').style.display = 'none';
                document.getElementById('exitFighterButton').style.display = 'none';
            }
        }

        window.addEventListener('resize', onWindowResize);

        // キャクターとアニメーションの設定の後に以下の行を追加
        placeLava();
        placeTemples();
        placeEnma(); // 閻魔大王を配置

        // TVモデルの読み込みと配置
        let tvModel;
        let displayMesh;

        gltfLoader.load('TV.glb', (gltf) => {
            tvModel = gltf.scene;
            tvModel.position.set(50, 0, -30); // TVの置を設定
            tvModel.scale.set(8, 8, 8); // TVのスケールを定
            
            // の向きを変更
            tvModel.rotation.y = Math.PI / 0.6; // Y軸周りに45度回転
           

            scene.add(tvModel);

            // displayメッシュを探す
            tvModel.traverse((node) => {
                if (node.isMesh && node.name.toLowerCase() === 'display') {
                    displayMesh = node;
                    console.log('ディスプレイのメッシュが見つかりました:', displayMesh);
                    createStaticEffect(displayMesh);
                }
            });

            if (!displayMesh) {
                console.warn('ディスプレイのメッシュが見つかりません');
            }
        });

        // 砂嵐フェクトの作成
        function createStaticEffect(mesh) {
            const staticTexture = new THREE.DataTexture(
                new Uint8Array(256 * 256 * 3),
                256, 256,
                THREE.RGBFormat
            );
            staticTexture.needsUpdate = true;

            const staticMaterial = new THREE.MeshBasicMaterial({
                map: staticTexture,
                transparent: true,
                opacity: 0.8
            });

            mesh.material = staticMaterial;

            function updateStatic() {
                const data = staticTexture.image.data;
                for (let i = 0; i < data.length; i++) {
                    data[i] = Math.random() * 255;
                }
                staticTexture.needsUpdate = true;
            }

            // アニメーションループに砂嵐エフェクトの更新を追加
            function animateStatic() {
                requestAnimationFrame(animateStatic);
                updateStatic();
            }

            animateStatic();
        }

        // グローバル変数を追加
        let isNearTV = false;
        let videoPromptShown = false;

        // テレビとの距離をックする関数
        function checkTVProximity() {
            if (!character || !tvModel) return;

            const distance = character.position.distanceTo(tvModel.position);
            if (distance < 20 && !isNearTV) { // 距が20未満になったらプロンプトを表示
                isNearTV = true;
                if (!videoPromptShown) {
                    showVideoPrompt();
                }
            } else if (distance >= 20) {
                isNearTV = false;
            }
        }

        // 動画を見るかどうかのプロンプトを表示する関数
        function showVideoPrompt() {
            const promptDiv = document.createElement('div');
            promptDiv.id = 'videoPrompt';
            promptDiv.style.position = 'absolute';
            promptDiv.style.top = '50%';
            promptDiv.style.left = '50%';
            promptDiv.style.transform = 'translate(-50%, -50%)';
            promptDiv.style.background = 'rgba(0, 0, 0, 0.8)';
            promptDiv.style.color = 'white';
            promptDiv.style.padding = '20px';
            promptDiv.style.borderRadius = '10px';
            promptDiv.style.zIndex = '1000';
            promptDiv.innerHTML = `
                <p>テレビを見ますか？</p>
                <button onclick="playVideo()">見る</button>
                <button onclick="closePrompt()">見ない</button>
            `;
            document.body.appendChild(promptDiv);
            videoPromptShown = true;
        }

        // 動画を再生する関数
        function playVideo() {
            closePrompt();
            const videoDiv = document.createElement('div');
            videoDiv.id = 'videoPlayer';
            videoDiv.innerHTML = `
                <iframe src="https://www.youtube.com/embed/1YWPIX-fRwA?autoplay=1" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>
                <button id="closeVideoButton" onclick="closeVideo()">×</button>
            `;
            document.body.appendChild(videoDiv);
        }

        // プロンプトを閉じる関数
        function closePrompt() {
            const promptDiv = document.getElementById('videoPrompt');
            if (promptDiv) {
                promptDiv.remove();
            }
            videoPromptShown = false;
        }

        // 動画を閉じる関数
        function closeVideo() {
            const videoDiv = document.getElementById('videoPlayer');
            if (videoDiv) {
                videoDiv.remove();
            }
            videoPromptShown = false;
        }

        // グローバル変数を追加
        let isNearDevil = false;
        let devilMessageShown = false;

        // 悪魔との距離をチェ��クする関数
        function checkDevilProximity() {
            if (!character || !devil) return;

            const distance = character.position.distanceTo(devil.position);
            if (distance < 20 && !isNearDevil) { // 距離が20未満になったらメッセージを表示
                isNearDevil = true;
                if (!devilMessageShown) {
                    showDevilMessage();
                }
            } else if (distance >= 20) {
                isNearDevil = false;
            }
        }

        // 悪魔のメッセージを表示する関数
        function showDevilMessage() {
            const messageDiv = document.createElement('div');
            messageDiv.id = 'devilMessage';
            messageDiv.style.position = 'absolute';
            messageDiv.style.top = '50%';
            messageDiv.style.left = '50%';
            messageDiv.style.transform = 'translate(-50%, -50%)';
            messageDiv.style.background = 'rgba(0, 0, 0, 0.8)';
            messageDiv.style.color = 'white';
            messageDiv.style.padding = '20px';
            messageDiv.style.borderRadius = '10px';
            messageDiv.style.zIndex = '1000';
            messageDiv.innerHTML = `
                <p>盆について知りたい？<br>じゃあテレビを探せ。<br>迷子になっても知らないがな。</p>
                <button onclick="closeDevilMessage()">了解</button>
            `;
            document.body.appendChild(messageDiv);
            devilMessageShown = true;
        }

        // 悪魔のメッセージを閉じる関数
        function closeDevilMessage() {
            const messageDiv = document.getElementById('devilMessage');
            if (messageDiv) {
                messageDiv.remove();
            }
            devilMessageShown = false;
        }

        startAnimationWhenReady();
    </script>
</body>
</html>